package {{$generatedArtifactPackageName}};

{{for importedClass : $importedClasses}}
import {{$importedClass}};
{{end}}

import static tech.intellispaces.reflections.framework.system.UnitMethods.unitMethod;

/**
 * Wrapper of module unit {@link {{$sourceArtifactSimpleName}}}.
 * <p>
 * This class was generated automatically. Don't try to change it.
 */
@Wrapper({{$sourceArtifactSimpleName}}.class)
{{$generatedAnnotation}}
public class {{$generatedArtifactSimpleName}}{{$typeParamsFullDeclaration}} extends {{$sourceArtifactSimpleName}}{{$typeParamsBriefDeclaration}} implements UnitWrapper {
  private static UnitType $unitType;
  private final UnitHandle $handle;

  public {{$generatedArtifactSimpleName}}(UnitHandle handle) {
    $handle = handle;
  }

  @Override
  public UnitType $unitType() {
    if ($unitType == null) {
      $unitType = $buildUnitType();
    }
    return $unitType;
  }

  @Override
  public UnitHandle $handle() {
    return this.$handle;
  }

{{for method : $injectionMethods}}
  {{$method->javadoc}}
{{for annotation : $method->annotations}}
  @{{$annotation}}
{{end}}
  public {{$method->signature}} {
    {{$method->body}}
  }
{{end}}
{{for method : $overrideGuideMethods}}
  @Override
  @Ordinal({{$method.index()}})
  {{$method->declaration}}

{{end}}
{{for method : $guideActionMethods}}
  {{$method->declaration}};

{{end}}

{{for method : $overrideProjectionMethods}}
  {{$method}}

{{end}}
  private static UnitType $buildUnitType() {
    return UnitTypes.create(
        {{$sourceArtifactSimpleName}}.class,
        List.of(
{{for method : $methodDescriptions}}
          unitMethod({{$generatedArtifactSimpleName}}.class, null, "{{$method->name}}"{{for param : $method->params}}, {{$param}}.class{{end}})
            .purpose(UnitMethodPurposes.{{$method->purpose}})
{{when $method->type.eq("function")}}
            .function({{$generatedArtifactSimpleName}}::{{$method->name}})
{{end}}
{{when $method->type.eq("consumer")}}
            .consumer({{$generatedArtifactSimpleName}}::{{$method->name}})
{{end}}
{{when $method->prototypeMethodName.isNotVoid()}}
            .prototypeMethodName("{{$method->prototypeMethodName}}")
{{end}}
{{when $method->injectionName.isNotVoid()}}
            .injectionName("{{$method->injectionName}}")
{{end}}
{{when $method->injectionClass.isNotVoid()}}
            .injectionClass({{$method->injectionClass}}.class)
{{end}}
{{when $method->injectionKind.isNotVoid()}}
            .injectionKind({{$method->injectionKind}})
{{end}}
{{when $method->injectionOrdinal.isNotVoid()}}
            .injectionOrdinal({{$method->injectionOrdinal}})
{{end}}
{{when $method->projectionName.isNotVoid()}}
            .projectionName("{{$method->projectionName}}")
{{end}}
{{when $method->targetClass.isNotVoid()}}
            .targetClass({{$method->targetClass}}.class)
{{end}}
{{when $method->requiredProjections.isNotVoid()}}
            .requiredProjections(ProjectionReferences.list(
{{for projection : $method->requiredProjections}}
              "{{$projection->name}}", {{$projection->class}}.class{{when $projection.isNotLast()}},{{end}}
{{end}}
             ))
{{end}}
{{when $method->lazyLoading.isNotVoid()}}
            .lazyLoading({{$method->lazyLoading}})
{{end}}
{{when $method->guideOrdinal.isNotVoid()}}
            .guideOrdinal({{$method->guideOrdinal}})
{{end}}
{{when $method->guideKind.isNotVoid()}}
            .guideKind(GuideKinds.{{$method->guideKind}})
{{end}}
{{when $method->guideCid.isNotVoid()}}
            .guideCid(Rids.create("{{$method->guideCid}}"))
{{end}}
{{when $method->guideTargetForm.isNotVoid()}}
            .guideTargetForm(ReflectionForms.{{$method->guideTargetForm}})
{{end}}
            .get(){{when $method.isNotLast()}},{{end}}
{{end}}
        )
    );
  }
}
